"""
Writer for amber

"""

import time
import pandas as pd
import math
import re
import numpy as np

# Python 2/3 compat
try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO

import eex
import logging

# AMBER local imports
from . import amber_metadata as amd

logger = logging.getLogger(__name__)


def write_amber_file(dl, filename, inpcrd=None):
    """
    Parameters
    ------------
    dl : eex.DataLayer
        The datalayer containing information about the system to write
    filename : str
        The name of the file to write
    inpcrd : str, optional
        If None, attempts to read the file filename.replace("prmtop", "inpcrd") otherwise passes. #
    """

    ### First get information into Amber pointers. All keys are initially filled with zero.
    # Ones that are currently 0, but should be implemented eventually are marked with

    output_sizes = {k: 0 for k in amd.size_keys}

    output_sizes['NATOM'] = dl.get_atom_count()  # Number of atoms
    output_sizes["MBONA"] = dl.get_term_count(2, "total")  #  Number of bonds not containing hydrogen
    output_sizes["MTHETA"] = dl.get_term_count(3, "total")  #  Number of angles not containing hydrogen
    # output_sizes["MPHIA"] = dl.get_term_count(4, "total")  #  Number of torsions not containing hydrogen
    output_sizes["NUMBND"] = len(dl.list_parameter_uids(2))  # Number of unique bond types
    output_sizes["NUMANG"] = len(dl.list_parameter_uids(3))  # Number of unique angle types
    output_sizes["NPTRA"] = len(dl.list_parameter_uids(4))  # Number of unique torsion types
    output_sizes["NTYPES"] = 0  # Number of distinct LJ atom types
    output_sizes["NBONH"] = 0  #  Number of bonds containing hydrogen
    output_sizes["NTHETH"] = 0  #  Number of angles containing hydrogen
    output_sizes["NPHIH"] = 0  #  Number of torsions containing hydrogen
    output_sizes["NPARM"] = 0  #  Used to determine if this is a LES-compatible prmtop (??)
    output_sizes["NNB"] = 0  #  Number of excluded atoms
    output_sizes["NRES"] = 0
    output_sizes["IFBOX"] = 0  #  Flag indicating whether a periodic box is present
    # 0 - no box, 1 - orthorhombic box, 2 - truncated octahedron
    output_sizes["NMXRS"] = 0  #  Number of atoms in the largest residue
    output_sizes["IFCAP"] = 0  # Set to 1 if a solvent CAP is being used
    output_sizes["NUMEXTRA"] = 0  # Number of extra points in the topology file

    ### Write title and version information
    f = open(filename, "w")
    f.write('%%VERSION  VERSION_STAMP = V0001.000  DATE = %s  %s\n' % (time.strftime("%x"), time.strftime("%H:%M:%S")))
    f.write("%FLAG TITLE\n%FORMAT(20a4)\n")
    f.write("prmtop generated by MolSSI EEX\n")

    ## Write pointers section
    f.write("%%FLAG POINTERS\n%s\n" % (amd.data_labels["POINTERS"][1]))
    ncols, dtype, width = amd.parse_format(amd.data_labels["POINTERS"][1])
    format_string = "%%%sd" % (width)

    count = 0
    for k in amd.size_keys:
        f.write(format_string % output_sizes[k])
        count += 1
        if count % ncols == 0:
            f.write("\n")

    f.write("\n")
    f.close()

    ## Write atom properties sections
    f = open(filename, "ab")

    for k in amd.atom_property_names:

        # Get data format
        fmt_data = amd.parse_format(amd.data_labels[k][1])
        ncols = fmt_data[0]
        fmt = amd.build_format(fmt_data)

        # Get unit type
        utype = None
        if k in amd.atom_data_units:
            utype = amd.atom_data_units[k]

        f.write(("%%FLAG %s\n" % k).encode())
        f.write(("%s\n" % amd.data_labels[k][1]).encode())

        # Get data
        data = dl.get_atoms(amd.atom_property_names[k], by_value=True, utype=utype).values.ravel()
        remainder_size = data.size % ncols
        rem_data = data[-remainder_size:].reshape(1, -1)
        data = data[:-remainder_size].reshape(-1, ncols)

        # Write data to file
        # print(data.shape, rem_data.shape, rem_data, fmt)
        np.savetxt(f, data, fmt=fmt, delimiter="")
        np.savetxt(f, rem_data, fmt=fmt, delimiter="")
        f.flush()

    f.close()

    return 0
