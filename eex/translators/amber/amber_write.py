"""
Writer for amber

"""

import time
import pandas as pd
import math
import re
import numpy as np

# Python 2/3 compat
try:
    from StringIO import StringIO
except ImportError:
    from io import StringIO

import eex
import logging

# AMBER local imports
from . import amber_metadata as amd

logger = logging.getLogger(__name__)


def write_amber_file(dl, filename, inpcrd=None):
    """
    Parameters
    ------------
    dl : eex.DataLayer
        The datalayer containing information about the system to write
    filename : str
        The name of the file to write
    inpcrd : str, optional
        If None, attempts to read the file filename.replace("prmtop", "inpcrd") otherwise passes. #NYI
    """

    ### First get information into Amber pointers. All keys are initially filled with zero.
    # Ones that are currently 0, but should be implemented eventually are marked with TODO

    output_sizes = {k: 0 for k in amd.size_keys}

    output_sizes['NATOM'] = dl.get_atoms("atom_type").shape[0]  # Number of atoms
    output_sizes["NTYPES"] = len((np.unique(dl.get_atoms("atom_type"))))  # Number of distinct LJ atom types
    output_sizes["NBONH"] = 0  # TODO Number of bonds containing hydrogen NYI
    output_sizes["MBONA"] = dl.get_bonds().shape[0]  # TODO Number of bonds not containing hydrogen
    output_sizes["NTHETH"] = 0  # TODO Number of angles containing hydrogen
    output_sizes["MTHETA"] = dl.get_angles().shape[0]  # TODO Number of angles not containing hydrogen
    output_sizes["NPHIH"] = 0  # TODO Number of torsions containing hydrogen
    output_sizes["MPHIA"] = 0  # TODO Number of torsions not containing hydrogen
    output_sizes["NPARM"] = 0  # TODO Used to determine if this is a LES-compatible prmtop (??)
    output_sizes["NNB"] = 0  # TODO Number of excluded atoms
    output_sizes["NRES"] = len(np.unique(dl.get_atoms("residue_index")))  # Number of residues
    output_sizes["NUMBND"] = len(np.unique(dl.get_bonds()["term_index"]))  # Number of unique bond types
    output_sizes["NUMANG"] = len(np.unique(dl.get_angles()["term_index"]))  # Number of unique angle types
    output_sizes["NPTRA"] = 0  # TODO Number of unique torsion types
    output_sizes["IFBOX"] = 0  # TODO Flag indicating whether a periodic box is present
    # 0 - no box, 1 - orthorhombic box, 2 - truncated octahedron
    output_sizes["NMXRS"] = 0  # TODO Number of atoms in the largest residue
    output_sizes["IFCAP"] = 0  # Set to 1 if a solvent CAP is being used
    output_sizes["NUMEXTRA"] = 0  # Number of extra points in the topology filgit discard changes

    ### Write title and version information
    f = open(filename, "w")
    f.write('%%VERSION  VERSION_STAMP = V0001.000  DATE = %s  %s\n' % (time.strftime("%x"), time.strftime("%H:%M:%S")))
    f.write("%FLAG TITLE\n%FORMAT(20a4)\n")
    f.write("prmtop generated by MolSSI EEX\n")

    ## Write pointers section
    f.write("%%FLAG POINTERS\n%s\n" % (amd.data_labels["POINTERS"][1]))
    ncols, dtype, width = amd.parse_format(amd.data_labels["POINTERS"][1])
    format_string = "%%%sd" % (width)

    count = 0
    for k in amd.size_keys:
        f.write(format_string % output_sizes[k])
        count += 1
        if count % ncols == 0:
            f.write("\n")

    f.write("\n")
    f.close()

    f = open(filename, "ab")
    ## Write atom properties sections
    for k in amd.atom_property_names:

        # Get data format
        format = amd.parse_format(amd.data_labels[k][1])
        # print(format)
        ncols = format[0]

        # Get unit type
        utype = None
        if k in amd.atom_data_units:
            utype = amd.atom_data_units[k]

        if format[1] == str:
            fmt = "%-" + str(format[2]) + "s"
        elif format[1] == float:
            fmt = " % " + str(format[2] - 1) + "." + str(format[4]) + "E"
        elif format[1] == int:
            fmt = " % " + str(format[2] - 1) + "d"
        else:
            raise TypeError("Type (%s) not recognized" % type(format[1]))

        f.write(("%%FLAG %s\n" % k).encode())
        f.write(("%s\n" % amd.data_labels[k][1]).encode())

        # Get data
        data = dl.get_atoms(amd.atom_property_names[k], by_value=True, utype=utype).values.ravel()
        remainder_size = data.size % ncols
        rem_data = data[-remainder_size:].reshape(1, -1)
        data = data[:-remainder_size].reshape(-1, ncols)

        # Write data to file
        print(data.shape, rem_data.shape, rem_data, fmt)
        np.savetxt(f, data, fmt=fmt, delimiter="")
        np.savetxt(f, rem_data, fmt=fmt, delimiter="")
        f.flush()

    f.close()

    return 0
